---
title: 🧠 LLM 与智能体（Agent）知识记录
date: 2025-10-21 21:00:00
categories:
  - 技术学习与行业趋势 / Learning & Industry Trends
  - AI与研究 / AI & Research
  - 提示工程 / Prompt Engineering
tags:
  - LLM
  - Agent
  - RAG
  - Prompt
  - AI助手
  - 知识整理
keywords: LLM, Agent, 智能体, RAG, Prompt, 测试自动化, 知识整理
description: '系统梳理 LLM 与 Agent 的概念、组成、原理与实践要点，配套学习路线与清单，助你快速上手智能体开发与应用'
top_img: /img/LLM-Agent.png
cover: /img/LLM-Agent.png
comments: true
toc: true
toc_number: true
toc_style_simple: false
copyright: true
copyright_author: yuxiaoling
copyright_info: 版权所有，转载请注明出处。
mathjax: false
katex: false
aplayer: false
highlight_shrink: false
aside: true
noticeOutdate: false
---

> 📘 本文旨在系统记录 LLM 与 Agent 的概念、组成、原理、应用与实践要点，形成长期可复用的知识材料。你可以将它作为“学习路线 + 实践清单”的参考。✅

---

## 基础认知

### 一、LLM（Large Language Model，大语言模型） 🤖
### 1.1 定义
LLM 是基于深度学习与海量文本训练的模型，能够理解、生成、推理自然语言，是现代智能体的“核心大脑”。

### 1.2 核心特性
| 特性 | 描述 |
|---|---|
| 理解能力 | 能理解问题、文档、上下文与意图 |
| 生成能力 | 能生成文章、代码、摘要、对话等 |
| 推理能力 | 能做基础逻辑判断与归纳总结 |
| 可扩展性 | 可与知识库、工具、API 联动 |
| 局限性 | 幻觉（hallucination）、知识截至训练时间、上下文窗口有限 |

### 1.3 关键概念
- `Prompt`：向模型输入的指令或问题，告诉模型“要做什么”。
- `Token`：模型处理文本的最小单位；长文本消耗更多资源。
- `Spec`（规范/说明书）：约束输入输出格式，定义任务规则。
- `RAG`（Retrieval-Augmented Generation）：结合外部知识库提升生成精确度。
- `上下文（Context）`：模型参考的历史对话或文本，用于生成连贯结果。

### 1.4 工作原理（简化）
1) 文本编码：将输入拆分为 Token 并转化为向量；
2) 模型推理：通过神经网络计算每个 Token 的概率；
3) 生成输出：根据概率生成下一个 Token；
4) 拼接文本：输出最终生成的文本结果。

---

### 二、Agent（智能体） 🛠️
### 2.1 定义
Agent 是在 LLM 基础上结合工具调用、流程编排与环境感知的系统，能够自主完成多步任务。

### 2.2 核心能力
| 能力 | 描述 |
|---|---|
| 观察环境 | 接收用户输入、文档、系统信息、API 输出 |
| 规划任务 | 拆解目标，制定执行步骤与顺序 |
| 执行操作 | 调用工具、接口、脚本、文件系统完成任务 |
| 反馈调整 | 根据执行结果优化下一步操作，形成闭环 |

### 2.3 组成模块
- LLM（大脑）：理解任务、生成计划与文本；
- Prompt + Spec（说明书）：定义角色、任务与输出格式；
- 工具调用模块（手脚）：API、脚本、数据库操作、文件操作；
- 记忆/上下文管理：保存历史信息，支持跨任务参考；
- 反馈机制：监控执行结果并调整策略。

### 2.4 工作流程（示意）
用户输入 → LLM理解 → 任务规划 → 调用工具 → 执行操作 → 结果反馈 → 上下文更新 → 输出 ✅

---

### 三、LLM 与 Agent 的关系 🔗
| 维度 | LLM | Agent |
|---|---|---|
| 功能 | 理解和生成语言 | 理解语言 + 执行任务 |
| 主动性 | 被动回答 | 主动规划与执行 |
| 输入 | Prompt | Prompt + 任务目标 + 可用工具 |
| 输出 | 文本 | 文本 + 执行结果 |
| 场景 | 问答、写作、摘要 | 自动化流程、智能助手、系统执行 |

> 总结：Agent 是 LLM 的进化，将语言理解与实际执行结合，实现“理解 → 决策 → 行动”的闭环。🧭

---

## 轻量实践：自动生成测试用例 📋
以“从需求文档生成测试用例 Excel”为例：
- 用户上传需求文档；
- LLM 理解文档内容与目标；
- Agent 规划字段（模块、用例名、步骤、预期结果）；
- LLM 生成测试用例文本；
- Agent 调脚本生成 Excel 文件；
- 返回文件并记录执行日志；
- 根据反馈调整生成策略。

Python 伪代码示例：
```python
requirements = load_doc("需求文档.docx")
plan = llm.generate_plan(requirements, task="生成测试用例")
test_cases = llm.generate_test_cases(plan)
excel_file = create_excel(test_cases)
send_to_user(excel_file)
```

Spec（规范）片段示例（YAML）：
```yaml
role: "测试用例生成器"
rules:
  - 输出必须包含: 模块, 用例名称, 前置条件, 步骤, 预期结果
  - 步骤为编号列表, 预期结果为可验证陈述
format:
  type: table
  columns: [module, name, precondition, steps, expected]
```

---

## 应用与工具

### 一、常见应用场景 🧩
- 办公自动化：整理报告、生成计划、发送邮件；
- 测试自动化：需求分析 → 用例生成 → 执行 → 报告；
- 客服系统：理解问题 → 调接口 → 自动回复；
- 内容创作：文章、代码、文案生成；
- 系统集成：多平台任务调度、状态监控、数据处理。


### 二、工具与框架 🧰
- LangChain：管理 LLM + 工具调用 + Agent 流程；
- AutoGPT / BabyAGI：多步任务 Agent 示例；
- RAG 方案：向量库 + 检索 + 重排 + 生成；
- 记忆管理：对话记忆、长期记忆（文件/数据库）。

选型建议：先从“轻量 + 可控”开始，逐步扩展工具数量与任务复杂度。✅

---

## 能力与局限 ⚖️
- 优势：多步任务自动化、效率提升、语言能力可落地；
- 局限：自主性越高风险越大（误操作/数据泄露）、Prompt/Spec 设计不当导致输出不准确、长任务规划与上下文管理仍是难点。

---

## 学习路线

- 先理解 LLM：掌握 Prompt、Token、上下文；
- 再尝试 Agent：从小任务练手（生成表格/整理报告）；
- 逐步扩展：多步任务、工具调用、记忆管理；
- 安全与可控：控制关键操作、记录日志、设置监控机制。

Checklist（自检清单）：
- 明确任务目标与边界；
- 定义 Spec 与输出格式；
- 选择必要工具（API/脚本/文件操作）；
- 配置日志与错误告警；
- 评估隐私与权限控制；
- 预留回滚与手动接管路径。

---

## 安全与治理🔒
- 权限分级：只授予必要权限（最小化原则）；
- 风险隔离：关键操作需二次确认或人工审批；
- 日志审计：记录请求、响应与工具调用明细；
- 数据脱敏：对敏感字段做掩码或匿名处理；
- 速率限制：防止资源滥用与雪崩；
- 可观测性：埋点与指标，便于定位与回溯。

---

## 常见坑位与规避 🪤
- 幻觉输出：引入 RAG 与校验规则（Spec）；
- 过度自主演化：限定工具范围与操作边界；
- 上下文丢失：持久化关键状态（记忆模块）；
- 无法复现：固定版本、固定 Prompt、固定数据样本；
- 任务中断：设置重试策略与补偿机制。

---

## Prompt 模板（可直接复用） 🧾
任务型模板：
```text
你的角色：测试用例编写助手
目标：根据输入需求生成覆盖率高、可执行的测试用例
输出格式：表格（模块、用例名、前置条件、步骤、预期结果）
约束：
- 步骤使用编号列表（1. 2. 3. ...）
- 预期结果为可验证陈述
- 覆盖主流程和异常场景
```

规范型模板（Spec）：
```text
角色：智能体编排器
规则：
- 任何关键文件写入前需用户确认
- 工具调用失败需重试 2 次并记录日志
- 超过 60 秒未响应需中断并提示人工介入
```

---

## 评估指标与基准 📏
| 指标 | 说明 | 目标 |
|---|---|---|
| 准确率 | 输出与任务规范一致的比例 | ≥ 95% |
| 覆盖率 | 需求点/场景覆盖情况 | ≥ 90% |
| 执行成功率 | 工具调用与脚本执行成功占比 | ≥ 98% |
| 回滚率 | 出错或异常导致的回滚比例 | ≤ 2% |
| 人工介入率 | 需人工处理的任务占比 | ≤ 5% |
| 响应时间 | 端到端时延 | ≤ 5s（视场景） |
| 成本 | Token/调用次数/资源占用 | 可控上限 |

---

## 错误处理与重试策略 🛡️
- 错误分层：输入错误（格式/缺字段）、检索错误（为空/质量低）、执行错误（网络/权限）、生成错误（超时/幻觉）。
- 策略：指数退避重试、熔断（停止级联失败）、降级（提供简化结果）、兜底提示（引导人工介入）。

错误与重试（概念介绍）：
- 重试策略：建议指数退避，限制最大重试次数，避免雪崩；
- 熔断与降级：连续失败触发熔断，输出简化结果并提示人工介入；
- 记录与告警：持久化日志，标注错误类型与日志ID，便于定位与审计。
---


📝 **文章至此结束** 感谢阅读！